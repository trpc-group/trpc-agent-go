//
// Tencent is pleased to support the open source community by making trpc-agent-go available.
//
// Copyright (C) 2025 Tencent.  All rights reserved.
//
// trpc-agent-go is licensed under the Apache License Version 2.0.
//
//

// Package main demonstrates a two-call external tool workflow against an AG-UI SSE server.
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"
	"time"

	"github.com/ag-ui-protocol/ag-ui/sdks/community/go/pkg/client/sse"
	"github.com/ag-ui-protocol/ag-ui/sdks/community/go/pkg/core/events"
	"github.com/ag-ui-protocol/ag-ui/sdks/community/go/pkg/core/types"
	"github.com/sirupsen/logrus"
)

const (
	defaultEndpoint  = "http://127.0.0.1:8080/agui"
	requestTimeout   = 2 * time.Minute
	connectTimeout   = 30 * time.Second
	readTimeout      = 5 * time.Minute
	streamBufferSize = 100

	externalToolName = "external_search"
)

var (
	endpoint      = flag.String("endpoint", defaultEndpoint, "AG-UI SSE endpoint.")
	threadID      = flag.String("thread", "demo-thread", "AG-UI threadId.")
	lineageID     = flag.String("lineage", "demo-lineage", "forwardedProps.lineage_id for checkpoint resume.")
	question      = flag.String("question", "What is trpc-agent-go?", "User question to send in call 1.")
	runID1        = flag.String("run1", "", "Run ID for call 1 (default: autogenerated).")
	runID2        = flag.String("run2", "", "Run ID for call 2 (default: autogenerated).")
	toolContent   = flag.String("tool-content", "", "Tool result content for call 2 (default: derived from tool args).")
	toolMessageID = flag.String("tool-message-id", "", "Tool message ID for call 2 (default: tool-result-<toolCallId>).")
	run1LogPath   = flag.String("run1-log", "", "Optional path to save call 1 SSE data lines.")
	run2LogPath   = flag.String("run2-log", "", "Optional path to save call 2 SSE data lines.")
)

type toolArgs struct {
	Query string `json:"query"`
}

func main() {
	flag.Parse()

	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	client := newSSEClient(*endpoint)
	defer client.Close()

	id1 := *runID1
	if id1 == "" {
		id1 = fmt.Sprintf("run-1-%d", time.Now().UnixNano())
	}
	id2 := *runID2
	if id2 == "" {
		id2 = fmt.Sprintf("run-2-%d", time.Now().UnixNano())
	}

	props := map[string]any{"lineage_id": *lineageID}

	fmt.Printf("Call 1: role=user, threadId=%s, runId=%s\n", *threadID, id1)
	call1 := types.RunAgentInput{
		ThreadID:       *threadID,
		RunID:          id1,
		ForwardedProps: props,
		Messages:       []types.Message{{Role: types.RoleUser, Content: *question}},
	}
	ctx1, cancel1 := context.WithTimeout(context.Background(), requestTimeout)
	defer cancel1()
	toolCallID, argsJSON, err := streamCall(ctx1, client, call1, 1, *run1LogPath)
	if err != nil {
		return fmt.Errorf("call 1: %w", err)
	}
	if toolCallID == "" {
		return fmt.Errorf("call 1: missing toolCallId for tool %q", externalToolName)
	}
	if strings.TrimSpace(argsJSON) == "" {
		return fmt.Errorf("call 1: missing tool args for toolCallId %s", toolCallID)
	}

	var parsed toolArgs
	if err := json.Unmarshal([]byte(argsJSON), &parsed); err != nil {
		return fmt.Errorf("parse tool args: %w", err)
	}

	content := *toolContent
	if content == "" {
		content = fmt.Sprintf("external_search result for query: %s", parsed.Query)
	}
	msgID := *toolMessageID
	if msgID == "" {
		msgID = fmt.Sprintf("tool-result-%s", toolCallID)
	}

	fmt.Printf("\nCall 2: role=tool, threadId=%s, runId=%s, toolCallId=%s\n", *threadID, id2, toolCallID)
	call2 := types.RunAgentInput{
		ThreadID:       *threadID,
		RunID:          id2,
		ForwardedProps: props,
		Messages: []types.Message{
			{
				ID:         msgID,
				Role:       types.RoleTool,
				Name:       externalToolName,
				ToolCallID: toolCallID,
				Content:    content,
			},
		},
	}
	ctx2, cancel2 := context.WithTimeout(context.Background(), requestTimeout)
	defer cancel2()
	if _, _, err := streamCall(ctx2, client, call2, 2, *run2LogPath); err != nil {
		return fmt.Errorf("call 2: %w", err)
	}
	return nil
}

func newSSEClient(endpoint string) *sse.Client {
	logger := logrus.New()
	logger.SetLevel(logrus.WarnLevel)

	return sse.NewClient(sse.Config{
		Endpoint:       endpoint,
		ConnectTimeout: connectTimeout,
		ReadTimeout:    readTimeout,
		BufferSize:     streamBufferSize,
		Logger:         logger,
	})
}

func streamCall(ctx context.Context, client *sse.Client, payload types.RunAgentInput, callIndex int,
	logPath string) (string, string, error) {
	logWriter, closeLog, err := openLogWriter(logPath)
	if err != nil {
		return "", "", fmt.Errorf("open log: %w", err)
	}
	if closeLog != nil {
		defer closeLog()
	}

	frames, errCh, err := client.Stream(sse.StreamOptions{Context: ctx, Payload: payload})
	if err != nil {
		return "", "", fmt.Errorf("start SSE stream: %w", err)
	}

	var toolCallID string
	var toolArgs strings.Builder

	for frames != nil || errCh != nil {
		select {
		case frame, ok := <-frames:
			if !ok {
				frames = nil
				continue
			}
			if logWriter != nil {
				if err := writeSSEDataLine(logWriter, frame.Data); err != nil {
					return "", "", fmt.Errorf("write log: %w", err)
				}
			}

			evt, err := events.EventFromJSON(frame.Data)
			if err != nil {
				return "", "", fmt.Errorf("parse event: %w", err)
			}
			fmt.Printf("[%d] %s\n", callIndex, formatEventSummary(evt))

			switch e := evt.(type) {
			case *events.ToolCallStartEvent:
				if toolCallID == "" && e.ToolCallName == externalToolName {
					toolCallID = e.ToolCallID
				}
			case *events.ToolCallArgsEvent:
				if toolCallID != "" && e.ToolCallID == toolCallID {
					toolArgs.WriteString(e.Delta)
				}
			}
		case err, ok := <-errCh:
			if !ok {
				errCh = nil
				continue
			}
			if err != nil {
				return "", "", fmt.Errorf("stream error: %w", err)
			}
		case <-ctx.Done():
			return "", "", fmt.Errorf("stream timeout: %w", ctx.Err())
		}
	}

	return toolCallID, toolArgs.String(), nil
}

func openLogWriter(path string) (io.Writer, func(), error) {
	if strings.TrimSpace(path) == "" {
		return nil, nil, nil
	}
	f, err := os.Create(path)
	if err != nil {
		return nil, nil, fmt.Errorf("create file: %w", err)
	}
	return f, func() { _ = f.Close() }, nil
}

func writeSSEDataLine(w io.Writer, data []byte) error {
	_, err := fmt.Fprintf(w, "data: %s\n\n", data)
	return err
}

func formatEventSummary(evt events.Event) string {
	if evt == nil {
		return "<nil>"
	}
	switch e := evt.(type) {
	case *events.RunStartedEvent:
		return fmt.Sprintf("RUN_STARTED threadId=%s runId=%s", e.ThreadID(), e.RunID())
	case *events.RunFinishedEvent:
		return fmt.Sprintf("RUN_FINISHED threadId=%s runId=%s", e.ThreadID(), e.RunID())
	case *events.RunErrorEvent:
		return fmt.Sprintf("RUN_ERROR %s", e.Message)
	case *events.ActivityDeltaEvent:
		return fmt.Sprintf("ACTIVITY_DELTA activityType=%s", e.ActivityType)
	case *events.ToolCallStartEvent:
		return fmt.Sprintf("TOOL_CALL_START name=%s toolCallId=%s", e.ToolCallName, e.ToolCallID)
	case *events.ToolCallArgsEvent:
		delta := strings.TrimSpace(e.Delta)
		if delta == "" {
			delta = "<empty>"
		}
		return fmt.Sprintf("TOOL_CALL_ARGS toolCallId=%s delta=%s", e.ToolCallID, delta)
	case *events.ToolCallEndEvent:
		return fmt.Sprintf("TOOL_CALL_END toolCallId=%s", e.ToolCallID)
	case *events.ToolCallResultEvent:
		return fmt.Sprintf("TOOL_CALL_RESULT toolCallId=%s", e.ToolCallID)
	case *events.TextMessageStartEvent:
		return fmt.Sprintf("TEXT_MESSAGE_START messageId=%s", e.MessageID)
	case *events.TextMessageContentEvent:
		delta := strings.TrimSpace(e.Delta)
		if delta == "" {
			return "TEXT_MESSAGE_CONTENT <empty>"
		}
		return fmt.Sprintf("TEXT_MESSAGE_CONTENT %s", delta)
	case *events.TextMessageEndEvent:
		return fmt.Sprintf("TEXT_MESSAGE_END messageId=%s", e.MessageID)
	case *events.CustomEvent:
		return fmt.Sprintf("CUSTOM name=%s", e.Name)
	default:
		return string(evt.Type())
	}
}
