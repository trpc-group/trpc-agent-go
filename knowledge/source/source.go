//
// Tencent is pleased to support the open source community by making trpc-agent-go available.
//
// Copyright (C) 2025 Tencent.  All rights reserved.
//
// trpc-agent-go is licensed under the Apache License Version 2.0.
//
//

// Package source defines the interface for knowledge sources.
package source

import (
	"context"
	"fmt"

	"trpc.group/trpc-go/trpc-agent-go/knowledge/document"
)

// Source types
const (
	TypeAuto = "auto"
	TypeFile = "file"
	TypeDir  = "dir"
	TypeURL  = "url"
)

// MetaPrefix is the prefix for all metadata keys generated by trpc-agent-go.
const MetaPrefix = "trpc_agent_go_"

// Metadata keys
const (
	MetaSource        = MetaPrefix + "source"
	MetaFilePath      = MetaPrefix + "file_path"
	MetaFileName      = MetaPrefix + "file_name"
	MetaFileExt       = MetaPrefix + "file_ext"
	MetaFileSize      = MetaPrefix + "file_size"
	MetaFileMode      = MetaPrefix + "file_mode"
	MetaModifiedAt    = MetaPrefix + "modified_at"
	MetaContentLength = MetaPrefix + "content_length"
	MetaFileCount     = MetaPrefix + "file_count"
	MetaFilePaths     = MetaPrefix + "file_paths"
	MetaURL           = MetaPrefix + "url"
	MetaURLHost       = MetaPrefix + "url_host"
	MetaURLPath       = MetaPrefix + "url_path"
	MetaURLScheme     = MetaPrefix + "url_scheme"
	MetaInputCount    = MetaPrefix + "input_count"
	MetaInputs        = MetaPrefix + "inputs"

	MetaChunkType = MetaPrefix + "chunk_type"
	MetaChunkSize = MetaPrefix + "chunk_size"

	// necessary metadata
	MetaURI                = MetaPrefix + "uri"                  // URI (absolute path / URL / md5 for pure text)
	MetaSourceName         = MetaPrefix + "source_name"          // source name
	MetaChunkIndex         = MetaPrefix + "chunk_index"          // chunk index
	MetaMarkdownHeaderPath = MetaPrefix + "markdown_header_path" // header path for markdown chunks
)

// Source represents a knowledge source that can provide documents.
type Source interface {
	// ReadDocuments reads and returns documents representing the source.
	// This method should handle the specific content type and return any errors.
	ReadDocuments(ctx context.Context) ([]*document.Document, error)

	// Name returns a human-readable name for this source.
	Name() string

	// Type returns the type of this source (e.g., "file", "url", "dir").
	Type() string

	// GetMetadata returns the metadata that user set
	GetMetadata() map[string]any
}

// MetadataFieldPrefix is the prefix for metadata fields in filter conditions.
// Fields with this prefix are treated as metadata fields and will be processed accordingly.
const MetadataFieldPrefix = "metadata."

// GetAllMetadata returns all metadata collected from sources with deduplication.
// Keys are prefixed with "metadata." for use in filter conditions.
func GetAllMetadata(sources []Source) map[string][]any {
	// Use temporary map for deduplication
	tempMetadataMap := make(map[string]map[string]struct{})
	allMetadata := make(map[string][]any)

	// Iterate through all sources to collect metadata
	for _, src := range sources {
		metadata := src.GetMetadata()
		for key, value := range metadata {
			// Add metadata prefix to key
			prefixedKey := MetadataFieldPrefix + key

			// Initialize key in temporary map
			if _, exists := tempMetadataMap[prefixedKey]; !exists {
				tempMetadataMap[prefixedKey] = make(map[string]struct{})
				allMetadata[prefixedKey] = make([]any, 0)
			}

			// Create a unique key that includes type information to avoid conflicts
			valueKey := fmt.Sprintf("%T:%v", value, value)
			if _, exists := tempMetadataMap[prefixedKey][valueKey]; !exists {
				allMetadata[prefixedKey] = append(allMetadata[prefixedKey], value)
				tempMetadataMap[prefixedKey][valueKey] = struct{}{}
			}
		}
	}
	return allMetadata
}

// GetAllMetadataWithoutValues returns all metadata keys with their string values collected from sources with deduplication.
// Keys are prefixed with "metadata." for use in filter conditions.
func GetAllMetadataWithoutValues(sources []Source) map[string][]any {
	result := make(map[string][]any)
	for _, src := range sources {
		metadata := src.GetMetadata()
		for key := range metadata {
			prefixedKey := MetadataFieldPrefix + key
			if _, exists := result[prefixedKey]; !exists {
				result[prefixedKey] = []any{}
			}
		}
	}
	return result
}

// GetAllMetadataKeys returns all metadata keys collected from sources with deduplication.
// Keys are prefixed with "metadata." for use in filter conditions.
func GetAllMetadataKeys(sources []Source) []string {
	allMetadata := GetAllMetadataWithoutValues(sources)
	result := make([]string, 0)
	for key := range allMetadata {
		result = append(result, key)
	}
	return result
}
