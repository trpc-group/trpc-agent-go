// Code generated by benchmark/tools/mathtools/generate.py; DO NOT EDIT.

package mathtools

import (
	"context"
	"encoding/json"
	"reflect"
	"testing"

	gomath "math"

	"trpc.group/trpc-go/trpc-agent-go/tool"
)

type testCase struct {
	name string
	args map[string]any
}

func findTool(t *testing.T, ts *ToolSet, name string) tool.CallableTool {
	t.Helper()
	for _, tl := range ts.Tools(context.Background()) {
		if tl.Declaration().Name != name {
			continue
		}
		ct, ok := tl.(tool.CallableTool)
		if !ok {
			t.Fatalf("tool %s is not callable", name)
		}
		return ct
	}
	t.Fatalf("tool %s not found", name)
	return nil
}

func expectedMath(name string, args map[string]any) map[string]any {
	switch name {
	case "Abs":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Abs(x)}

	case "Acos":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Acos(x)}

	case "Acosh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Acosh(x)}

	case "Asin":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Asin(x)}

	case "Asinh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Asinh(x)}

	case "Atan":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Atan(x)}

	case "Atan2":
		y := args["y"].(float64)
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Atan2(y, x)}

	case "Atanh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Atanh(x)}

	case "Cbrt":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Cbrt(x)}

	case "Ceil":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Ceil(x)}

	case "Copysign":
		f := args["f"].(float64)
		sign := args["sign"].(float64)
		return map[string]any{"result": gomath.Copysign(f, sign)}

	case "Cos":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Cos(x)}

	case "Cosh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Cosh(x)}

	case "Dim":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Dim(x, y)}

	case "Erf":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Erf(x)}

	case "Erfc":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Erfc(x)}

	case "Erfcinv":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Erfcinv(x)}

	case "Erfinv":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Erfinv(x)}

	case "Exp":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Exp(x)}

	case "Exp2":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Exp2(x)}

	case "Expm1":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Expm1(x)}

	case "FMA":
		x := args["x"].(float64)
		y := args["y"].(float64)
		z := args["z"].(float64)
		return map[string]any{"result": gomath.FMA(x, y, z)}

	case "Float32bits":
		f := float32(args["f"].(float64))
		return map[string]any{"result": gomath.Float32bits(f)}

	case "Float32frombits":
		b := uint32(args["b"].(float64))
		return map[string]any{"result": gomath.Float32frombits(b)}

	case "Float64bits":
		f := args["f"].(float64)
		return map[string]any{"result": gomath.Float64bits(f)}

	case "Float64frombits":
		b := uint64(args["b"].(float64))
		return map[string]any{"result": gomath.Float64frombits(b)}

	case "Floor":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Floor(x)}

	case "Frexp":
		f := args["f"].(float64)
		frac, exp := gomath.Frexp(f)
		return map[string]any{"frac": frac, "exp": exp}

	case "Gamma":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Gamma(x)}

	case "Hypot":
		p := args["p"].(float64)
		q := args["q"].(float64)
		return map[string]any{"result": gomath.Hypot(p, q)}

	case "Ilogb":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Ilogb(x)}

	case "Inf":
		sign := int(args["sign"].(float64))
		return map[string]any{"result": gomath.Inf(sign)}

	case "IsInf":
		f := args["f"].(float64)
		sign := int(args["sign"].(float64))
		return map[string]any{"result": gomath.IsInf(f, sign)}

	case "IsNaN":
		f := args["f"].(float64)
		return map[string]any{"result": gomath.IsNaN(f)}

	case "J0":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.J0(x)}

	case "J1":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.J1(x)}

	case "Jn":
		n := int(args["n"].(float64))
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Jn(n, x)}

	case "Ldexp":
		frac := args["frac"].(float64)
		exp := int(args["exp"].(float64))
		return map[string]any{"result": gomath.Ldexp(frac, exp)}

	case "Lgamma":
		x := args["x"].(float64)
		lgamma, sign := gomath.Lgamma(x)
		return map[string]any{"lgamma": lgamma, "sign": sign}

	case "Log":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Log(x)}

	case "Log10":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Log10(x)}

	case "Log1p":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Log1p(x)}

	case "Log2":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Log2(x)}

	case "Logb":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Logb(x)}

	case "Max":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Max(x, y)}

	case "Min":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Min(x, y)}

	case "Mod":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Mod(x, y)}

	case "Modf":
		f := args["f"].(float64)
		integer, fractional := gomath.Modf(f)
		return map[string]any{"integer": integer, "fractional": fractional}

	case "NaN":
		return map[string]any{"result": gomath.NaN()}

	case "Nextafter":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Nextafter(x, y)}

	case "Nextafter32":
		x := float32(args["x"].(float64))
		y := float32(args["y"].(float64))
		return map[string]any{"result": gomath.Nextafter32(x, y)}

	case "Pow":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Pow(x, y)}

	case "Pow10":
		n := int(args["n"].(float64))
		return map[string]any{"result": gomath.Pow10(n)}

	case "Remainder":
		x := args["x"].(float64)
		y := args["y"].(float64)
		return map[string]any{"result": gomath.Remainder(x, y)}

	case "Round":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Round(x)}

	case "RoundToEven":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.RoundToEven(x)}

	case "Signbit":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Signbit(x)}

	case "Sin":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Sin(x)}

	case "Sincos":
		x := args["x"].(float64)
		sin, cos := gomath.Sincos(x)
		return map[string]any{"sin": sin, "cos": cos}

	case "Sinh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Sinh(x)}

	case "Sqrt":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Sqrt(x)}

	case "Tan":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Tan(x)}

	case "Tanh":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Tanh(x)}

	case "Trunc":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Trunc(x)}

	case "Y0":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Y0(x)}

	case "Y1":
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Y1(x)}

	case "Yn":
		n := int(args["n"].(float64))
		x := args["x"].(float64)
		return map[string]any{"result": gomath.Yn(n, x)}
	default:
		panic("missing expected case: " + name)
	}
}

func equalValue(a, b any) bool {
	switch av := a.(type) {
	case float64:
		bv, ok := b.(float64)
		if !ok {
			return false
		}
		if gomath.IsNaN(av) && gomath.IsNaN(bv) {
			return true
		}
		return av == bv
	case float32:
		bv, ok := b.(float32)
		if !ok {
			return false
		}
		if gomath.IsNaN(float64(av)) && gomath.IsNaN(float64(bv)) {
			return true
		}
		return av == bv
	default:
		return reflect.DeepEqual(a, b)
	}
}

func TestMathTools_AllFunctions_TableDriven(t *testing.T) {
	ts, err := NewToolSet()
	if err != nil {
		t.Fatalf("NewToolSet: %v", err)
	}

	cases := []testCase{
		{name: "Abs", args: map[string]any{"x": float64(0.5)}},
		{name: "Acos", args: map[string]any{"x": float64(0.5)}},
		{name: "Acosh", args: map[string]any{"x": float64(1.5)}},
		{name: "Asin", args: map[string]any{"x": float64(0.5)}},
		{name: "Asinh", args: map[string]any{"x": float64(0.5)}},
		{name: "Atan", args: map[string]any{"x": float64(0.5)}},
		{name: "Atan2", args: map[string]any{"y": float64(1.0), "x": float64(2.0)}},
		{name: "Atanh", args: map[string]any{"x": float64(0.5)}},
		{name: "Cbrt", args: map[string]any{"x": float64(0.5)}},
		{name: "Ceil", args: map[string]any{"x": float64(0.5)}},
		{name: "Copysign", args: map[string]any{"f": float64(2.0), "sign": float64(-3.0)}},
		{name: "Cos", args: map[string]any{"x": float64(0.5)}},
		{name: "Cosh", args: map[string]any{"x": float64(0.5)}},
		{name: "Dim", args: map[string]any{"x": float64(5.0), "y": float64(2.0)}},
		{name: "Erf", args: map[string]any{"x": float64(0.5)}},
		{name: "Erfc", args: map[string]any{"x": float64(0.5)}},
		{name: "Erfcinv", args: map[string]any{"x": float64(0.5)}},
		{name: "Erfinv", args: map[string]any{"x": float64(0.5)}},
		{name: "Exp", args: map[string]any{"x": float64(0.5)}},
		{name: "Exp2", args: map[string]any{"x": float64(0.5)}},
		{name: "Expm1", args: map[string]any{"x": float64(0.5)}},
		{name: "FMA", args: map[string]any{"x": float64(1.25), "y": float64(2.5), "z": float64(3.75)}},
		{name: "Float32bits", args: map[string]any{"f": float64(1.5)}},
		{name: "Float32frombits", args: map[string]any{"b": float64(1069547520)}},
		{name: "Float64bits", args: map[string]any{"f": float64(0.5)}},
		{name: "Float64frombits", args: map[string]any{"b": float64(4609434218613702656)}},
		{name: "Floor", args: map[string]any{"x": float64(0.5)}},
		{name: "Frexp", args: map[string]any{"f": float64(8.0)}},
		{name: "Gamma", args: map[string]any{"x": float64(0.5)}},
		{name: "Hypot", args: map[string]any{"p": float64(3.0), "q": float64(4.0)}},
		{name: "Ilogb", args: map[string]any{"x": float64(0.5)}},
		{name: "Inf", args: map[string]any{"sign": float64(1)}},
		{name: "IsInf", args: map[string]any{"f": float64(1.0), "sign": float64(1)}},
		{name: "IsNaN", args: map[string]any{"f": float64(1.0)}},
		{name: "J0", args: map[string]any{"x": float64(0.5)}},
		{name: "J1", args: map[string]any{"x": float64(0.5)}},
		{name: "Jn", args: map[string]any{"n": float64(2), "x": float64(0.5)}},
		{name: "Ldexp", args: map[string]any{"frac": float64(0.5), "exp": float64(2)}},
		{name: "Lgamma", args: map[string]any{"x": float64(0.5)}},
		{name: "Log", args: map[string]any{"x": float64(0.5)}},
		{name: "Log10", args: map[string]any{"x": float64(0.5)}},
		{name: "Log1p", args: map[string]any{"x": float64(0.5)}},
		{name: "Log2", args: map[string]any{"x": float64(0.5)}},
		{name: "Logb", args: map[string]any{"x": float64(0.5)}},
		{name: "Max", args: map[string]any{"x": float64(0.5), "y": float64(0.5)}},
		{name: "Min", args: map[string]any{"x": float64(0.5), "y": float64(0.5)}},
		{name: "Mod", args: map[string]any{"x": float64(5.0), "y": float64(2.0)}},
		{name: "Modf", args: map[string]any{"f": float64(3.14)}},
		{name: "NaN", args: map[string]any{}},
		{name: "Nextafter", args: map[string]any{"x": float64(1.0), "y": float64(2.0)}},
		{name: "Nextafter32", args: map[string]any{"x": float64(1.0), "y": float64(2.0)}},
		{name: "Pow", args: map[string]any{"x": float64(2.0), "y": float64(3.0)}},
		{name: "Pow10", args: map[string]any{"n": float64(3)}},
		{name: "Remainder", args: map[string]any{"x": float64(5.0), "y": float64(2.0)}},
		{name: "Round", args: map[string]any{"x": float64(2.5)}},
		{name: "RoundToEven", args: map[string]any{"x": float64(2.5)}},
		{name: "Signbit", args: map[string]any{"x": float64(-1.0)}},
		{name: "Sin", args: map[string]any{"x": float64(0.5)}},
		{name: "Sincos", args: map[string]any{"x": float64(0.5)}},
		{name: "Sinh", args: map[string]any{"x": float64(0.5)}},
		{name: "Sqrt", args: map[string]any{"x": float64(0.5)}},
		{name: "Tan", args: map[string]any{"x": float64(0.5)}},
		{name: "Tanh", args: map[string]any{"x": float64(0.5)}},
		{name: "Trunc", args: map[string]any{"x": float64(0.5)}},
		{name: "Y0", args: map[string]any{"x": float64(0.5)}},
		{name: "Y1", args: map[string]any{"x": float64(0.5)}},
		{name: "Yn", args: map[string]any{"n": float64(2), "x": float64(0.5)}},
	}

	if len(cases) != len(ts.tools) {
		t.Fatalf("case count (%d) != tool count (%d)", len(cases), len(ts.tools))
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			ct := findTool(t, ts, tc.name)
			jsonArgs, err := json.Marshal(tc.args)
			if err != nil {
				t.Fatalf("marshal args: %v", err)
			}
			got, err := ct.Call(context.Background(), jsonArgs)
			if err != nil {
				t.Fatalf("Call: %v", err)
			}
			want := expectedMath(tc.name, tc.args)
			gm, ok := got.(map[string]any)
			if !ok {
				t.Fatalf("got is %T, want map[string]any", got)
			}
			for k, wv := range want {
				gv, ok := gm[k]
				if !ok {
					t.Fatalf("missing key %q in result: %#v", k, gm)
				}
				if !equalValue(gv, wv) {
					t.Fatalf("%s.%s = %#v (%T), want %#v (%T)", tc.name, k, gv, gv, wv, wv)
				}
			}
		})
	}
}
