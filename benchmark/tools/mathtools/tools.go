// Code generated by benchmark/tools/mathtools/generate.py; DO NOT EDIT.

package mathtools

import (
    "context"
    _ "embed"
    "encoding/json"
    "fmt"
    gomath "math"

    "trpc.group/trpc-go/trpc-agent-go/tool"
)

//go:embed schemas.json
var schemasJSON []byte

// ToolSet implements tool.ToolSet for Go's standard library math package.
//
// Tool declarations (name/description/inputSchema/outputSchema) are loaded from embedded `schemas.json`.
// Tool execution is backed by calling the official Go SDK `math.<Func>`.
type ToolSet struct {
    name  string
    tools []tool.Tool
}

// NewToolSet constructs a math toolset.
func NewToolSet() (*ToolSet, error) {
    var decls []tool.Declaration
    if err := json.Unmarshal(schemasJSON, &decls); err != nil {
        return nil, fmt.Errorf("unmarshal schemas.json: %w", err)
    }

    tools := make([]tool.Tool, 0, len(decls))
    for i := range decls {
        decl := new(tool.Declaration)
        *decl = decls[i]
        tools = append(tools, &mathTool{decl: decl})
    }

    return &ToolSet{
        name:  "math",
        tools: tools,
    }, nil
}

// Tools implements tool.ToolSet.
func (t *ToolSet) Tools(_ context.Context) []tool.Tool {
    return t.tools
}

// Close implements tool.ToolSet.
func (t *ToolSet) Close() error {
    return nil
}

// Name implements tool.ToolSet.
func (t *ToolSet) Name() string {
    return t.name
}

type mathTool struct {
    decl *tool.Declaration
}

func (t *mathTool) Declaration() *tool.Declaration {
    return t.decl
}

func (t *mathTool) Call(_ context.Context, jsonArgs []byte) (any, error) {
    args := map[string]any{}
    if len(jsonArgs) > 0 {
        if err := json.Unmarshal(jsonArgs, &args); err != nil {
            return nil, err
        }
    }
    return callMath(t.decl.Name, args)
}

var _ tool.Tool = (*mathTool)(nil)
var _ tool.CallableTool = (*mathTool)(nil)

func getFloat64(args map[string]any, key string) (float64, error) {
    v, ok := args[key]
    if !ok {
        return 0, fmt.Errorf("missing required argument: %s", key)
    }
    n, ok := v.(float64)
    if !ok {
        return 0, fmt.Errorf("%s must be a number", key)
    }
    return n, nil
}

func getFloat32(args map[string]any, key string) (float32, error) {
    n, err := getFloat64(args, key)
    if err != nil {
        return 0, err
    }
    return float32(n), nil
}

func getInt(args map[string]any, key string) (int, error) {
    n, err := getFloat64(args, key)
    if err != nil {
        return 0, err
    }
    if gomath.Trunc(n) != n {
        return 0, fmt.Errorf("%s must be an integer", key)
    }
    if n < float64(gomath.MinInt) || n > float64(gomath.MaxInt) {
        return 0, fmt.Errorf("%s out of int range", key)
    }
    return int(n), nil
}

func getUint32(args map[string]any, key string) (uint32, error) {
    n, err := getFloat64(args, key)
    if err != nil {
        return 0, err
    }
    if gomath.Trunc(n) != n {
        return 0, fmt.Errorf("%s must be an integer", key)
    }
    if n < 0 || n > float64(gomath.MaxUint32) {
        return 0, fmt.Errorf("%s out of uint32 range", key)
    }
    return uint32(n), nil
}

func getUint64(args map[string]any, key string) (uint64, error) {
    n, err := getFloat64(args, key)
    if err != nil {
        return 0, err
    }
    if gomath.Trunc(n) != n {
        return 0, fmt.Errorf("%s must be an integer", key)
    }
    if n < 0 || n > float64(gomath.MaxUint64) {
        return 0, fmt.Errorf("%s out of uint64 range", key)
    }
    return uint64(n), nil
}

func getBool(args map[string]any, key string) (bool, error) {
    v, ok := args[key]
    if !ok {
        return false, fmt.Errorf("missing required argument: %s", key)
    }
    b, ok := v.(bool)
    if !ok {
        return false, fmt.Errorf("%s must be a boolean", key)
    }
    return b, nil
}

func callMath(name string, args map[string]any) (any, error) {
    switch name {
	case "Abs":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Abs(x)}, nil

	case "Acos":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Acos(x)}, nil

	case "Acosh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Acosh(x)}, nil

	case "Asin":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Asin(x)}, nil

	case "Asinh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Asinh(x)}, nil

	case "Atan":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Atan(x)}, nil

	case "Atan2":
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Atan2(y, x)}, nil

	case "Atanh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Atanh(x)}, nil

	case "Cbrt":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Cbrt(x)}, nil

	case "Ceil":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Ceil(x)}, nil

	case "Copysign":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		sign, err := getFloat64(args, "sign")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Copysign(f, sign)}, nil

	case "Cos":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Cos(x)}, nil

	case "Cosh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Cosh(x)}, nil

	case "Dim":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Dim(x, y)}, nil

	case "Erf":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Erf(x)}, nil

	case "Erfc":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Erfc(x)}, nil

	case "Erfcinv":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Erfcinv(x)}, nil

	case "Erfinv":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Erfinv(x)}, nil

	case "Exp":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Exp(x)}, nil

	case "Exp2":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Exp2(x)}, nil

	case "Expm1":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Expm1(x)}, nil

	case "FMA":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		z, err := getFloat64(args, "z")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.FMA(x, y, z)}, nil

	case "Float32bits":
		f, err := getFloat32(args, "f")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Float32bits(f)}, nil

	case "Float32frombits":
		b, err := getUint32(args, "b")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Float32frombits(b)}, nil

	case "Float64bits":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Float64bits(f)}, nil

	case "Float64frombits":
		b, err := getUint64(args, "b")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Float64frombits(b)}, nil

	case "Floor":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Floor(x)}, nil

	case "Frexp":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		frac, exp := gomath.Frexp(f)
		return map[string]any{"frac": frac, "exp": exp}, nil

	case "Gamma":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Gamma(x)}, nil

	case "Hypot":
		p, err := getFloat64(args, "p")
		if err != nil { return nil, err }
		q, err := getFloat64(args, "q")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Hypot(p, q)}, nil

	case "Ilogb":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Ilogb(x)}, nil

	case "Inf":
		sign, err := getInt(args, "sign")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Inf(sign)}, nil

	case "IsInf":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		sign, err := getInt(args, "sign")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.IsInf(f, sign)}, nil

	case "IsNaN":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.IsNaN(f)}, nil

	case "J0":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.J0(x)}, nil

	case "J1":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.J1(x)}, nil

	case "Jn":
		n, err := getInt(args, "n")
		if err != nil { return nil, err }
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Jn(n, x)}, nil

	case "Ldexp":
		frac, err := getFloat64(args, "frac")
		if err != nil { return nil, err }
		exp, err := getInt(args, "exp")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Ldexp(frac, exp)}, nil

	case "Lgamma":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		lgamma, sign := gomath.Lgamma(x)
		return map[string]any{"lgamma": lgamma, "sign": sign}, nil

	case "Log":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Log(x)}, nil

	case "Log10":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Log10(x)}, nil

	case "Log1p":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Log1p(x)}, nil

	case "Log2":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Log2(x)}, nil

	case "Logb":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Logb(x)}, nil

	case "Max":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Max(x, y)}, nil

	case "Min":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Min(x, y)}, nil

	case "Mod":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Mod(x, y)}, nil

	case "Modf":
		f, err := getFloat64(args, "f")
		if err != nil { return nil, err }
		integer, fractional := gomath.Modf(f)
		return map[string]any{"integer": integer, "fractional": fractional}, nil

	case "NaN":
		return map[string]any{"result": gomath.NaN()}, nil

	case "Nextafter":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Nextafter(x, y)}, nil

	case "Nextafter32":
		x, err := getFloat32(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat32(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Nextafter32(x, y)}, nil

	case "Pow":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Pow(x, y)}, nil

	case "Pow10":
		n, err := getInt(args, "n")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Pow10(n)}, nil

	case "Remainder":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		y, err := getFloat64(args, "y")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Remainder(x, y)}, nil

	case "Round":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Round(x)}, nil

	case "RoundToEven":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.RoundToEven(x)}, nil

	case "Signbit":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Signbit(x)}, nil

	case "Sin":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Sin(x)}, nil

	case "Sincos":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		sin, cos := gomath.Sincos(x)
		return map[string]any{"sin": sin, "cos": cos}, nil

	case "Sinh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Sinh(x)}, nil

	case "Sqrt":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Sqrt(x)}, nil

	case "Tan":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Tan(x)}, nil

	case "Tanh":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Tanh(x)}, nil

	case "Trunc":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Trunc(x)}, nil

	case "Y0":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Y0(x)}, nil

	case "Y1":
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Y1(x)}, nil

	case "Yn":
		n, err := getInt(args, "n")
		if err != nil { return nil, err }
		x, err := getFloat64(args, "x")
		if err != nil { return nil, err }
		return map[string]any{"result": gomath.Yn(n, x)}, nil
    default:
        return nil, fmt.Errorf("unknown math function: %s", name)
    }
}
