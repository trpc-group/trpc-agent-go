package planner

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"trpc.group/trpc-go/trpc-agent-go/message"
	"trpc.group/trpc-go/trpc-agent-go/model"
)

var (
	// ErrNoModel is returned when no model is provided to the planner.
	ErrNoModel = errors.New("no model provided")
	// ErrPlanGenerationFailed is returned when plan generation fails.
	ErrPlanGenerationFailed = errors.New("plan generation failed")
	// ErrInvalidPlanFormat is returned when the plan format is invalid.
	ErrInvalidPlanFormat = errors.New("invalid plan format")
)

// LLMPlannerConfig contains the configuration for an LLMPlanner.
type LLMPlannerConfig struct {
	// Name is the name of the planner.
	Name string
	// Description is a description of the planner.
	Description string
	// Model is the language model used for plan generation.
	Model model.Model
	// SystemPrompt is the system prompt for the model.
	SystemPrompt string
	// Temperature controls the randomness of the model output.
	Temperature float32
	// MaxTokens is the maximum number of tokens to generate.
	MaxTokens int
	// Monitor is the execution monitor for plans.
	Monitor PlanExecutionMonitor
}

// DefaultLLMPlannerConfig returns the default configuration for an LLMPlanner.
func DefaultLLMPlannerConfig() LLMPlannerConfig {
	return LLMPlannerConfig{
		Name:        "LLMPlanner",
		Description: "A planner that uses language models to generate plans",
		Temperature: 0.2, // Lower temperature for more deterministic planning
		MaxTokens:   2048,
		SystemPrompt: `You are a planning assistant that creates detailed and executable plans.
Given a goal, you will create a plan with discrete tasks and steps to accomplish that goal.
Each plan should include:
1. A clear breakdown of tasks required to achieve the goal
2. Dependencies between tasks (if any)
3. Specific, actionable steps for each task
4. Parameters needed for each step
The plan should be practical, efficient, and complete.`,
	}
}

// LLMPlanner is a planner that uses language models to generate plans.
type LLMPlanner struct {
	BasePlanner
	config    LLMPlannerConfig
	model     model.Model
	generator PlanGenerator
}

// PlanGenerator is a function type that generates a plan from a goal.
type PlanGenerator func(ctx context.Context, goal string, options map[string]interface{}) (PlanDescription, error)

// PlanDescription represents a structured description of a plan generated by an LLM.
type PlanDescription struct {
	Goal  string            `json:"goal"`
	Tasks []TaskDescription `json:"tasks"`
}

// TaskDescription represents a structured description of a task generated by an LLM.
type TaskDescription struct {
	ID           string            `json:"id"`
	Description  string            `json:"description"`
	Dependencies []string          `json:"dependencies,omitempty"`
	Priority     int               `json:"priority,omitempty"`
	Steps        []StepDescription `json:"steps"`
}

// StepDescription represents a structured description of a step generated by an LLM.
type StepDescription struct {
	ID          string                 `json:"id"`
	Description string                 `json:"description"`
	Action      string                 `json:"action"`
	Parameters  map[string]interface{} `json:"parameters,omitempty"`
}

// NewLLMPlanner creates a new LLMPlanner with the given configuration.
func NewLLMPlanner(config LLMPlannerConfig) (*LLMPlanner, error) {
	if config.Model == nil {
		return nil, ErrNoModel
	}

	basePlanner := NewBasePlanner(config.Name, config.Description)
	if config.Monitor != nil {
		basePlanner.SetExecutionMonitor(config.Monitor)
	}

	planner := &LLMPlanner{
		BasePlanner: *basePlanner,
		config:      config,
		model:       config.Model,
	}

	planner.generator = planner.defaultPlanGenerator

	return planner, nil
}

// CreatePlan generates a new plan for the given goal using the LLM.
func (p *LLMPlanner) CreatePlan(ctx context.Context, goal string, options map[string]interface{}) (Plan, error) {
	if goal == "" {
		return nil, ErrInvalidGoal
	}

	// Generate a plan using the LLM
	planDesc, err := p.generator(ctx, goal, options)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrPlanGenerationFailed, err)
	}

	// Create a base plan
	planID := fmt.Sprintf("plan-%d", time.Now().UnixNano())
	plan := NewBasePlan(planID, goal)

	// Add tasks to the plan
	for _, taskDesc := range planDesc.Tasks {
		task := NewBaseTask(taskDesc.ID, taskDesc.Description)
		task.SetPriority(taskDesc.Priority)

		// Add task dependencies
		for _, dep := range taskDesc.Dependencies {
			if err := task.AddDependency(dep); err != nil {
				return nil, err
			}
		}

		// Add steps to the task
		for _, stepDesc := range taskDesc.Steps {
			step := NewBaseStep(stepDesc.ID, stepDesc.Description, stepDesc.Action)

			// Add parameters to the step
			for key, value := range stepDesc.Parameters {
				step.SetParameter(key, value)
			}

			if err := task.AddStep(step); err != nil {
				return nil, err
			}
		}

		// Add the task to the plan
		if err := plan.AddTask(task); err != nil {
			return nil, err
		}
	}

	// Store the plan
	p.mu.Lock()
	p.plans[planID] = plan
	p.mu.Unlock()

	return plan, nil
}

// defaultPlanGenerator is the default implementation of the plan generator.
func (p *LLMPlanner) defaultPlanGenerator(ctx context.Context, goal string, options map[string]interface{}) (PlanDescription, error) {
	// Prepare the system prompt
	systemMsg := message.NewSystemMessage(p.config.SystemPrompt)

	// Prepare the user prompt
	userPrompt := fmt.Sprintf(`Goal: %s

Please create a detailed plan to accomplish this goal. Your plan should include:
1. A clear breakdown of tasks required to achieve the goal
2. Dependencies between tasks (if any)
3. Specific, actionable steps for each task
4. Parameters needed for each step

Respond with a valid JSON object containing the plan, with this structure:
{
  "goal": "The goal statement",
  "tasks": [
    {
      "id": "task-1",
      "description": "Description of the task",
      "dependencies": ["task-id-that-must-complete-first"],
      "priority": 1,
      "steps": [
        {
          "id": "step-1",
          "description": "Description of the step",
          "action": "specific_action_name",
          "parameters": {
            "param1": "value1",
            "param2": 42
          }
        }
      ]
    }
  ]
}`, goal)

	userMsg := message.NewUserMessage(userPrompt)

	// Generate a completion with the model
	genOptions := model.GenerationOptions{
		Temperature: p.config.Temperature,
		MaxTokens:   p.config.MaxTokens,
	}

	response, err := p.model.GenerateWithMessages(ctx, []*message.Message{systemMsg, userMsg}, genOptions)
	if err != nil {
		return PlanDescription{}, err
	}

	if len(response.Messages) == 0 {
		return PlanDescription{}, ErrPlanGenerationFailed
	}

	// Extract the JSON plan from the response
	assistantMsg := response.Messages[0]
	content := assistantMsg.Content

	// Try to find JSON in the response
	jsonStart := strings.Index(content, "{")
	jsonEnd := strings.LastIndex(content, "}")
	if jsonStart == -1 || jsonEnd == -1 || jsonEnd <= jsonStart {
		return PlanDescription{}, ErrInvalidPlanFormat
	}

	jsonContent := content[jsonStart : jsonEnd+1]

	// Parse the JSON plan
	var planDesc PlanDescription
	if err := json.Unmarshal([]byte(jsonContent), &planDesc); err != nil {
		return PlanDescription{}, fmt.Errorf("%w: %v", ErrInvalidPlanFormat, err)
	}

	return planDesc, nil
}

// SetPlanGenerator sets a custom plan generator function.
func (p *LLMPlanner) SetPlanGenerator(generator PlanGenerator) {
	p.generator = generator
}

// GetModel returns the language model used by the planner.
func (p *LLMPlanner) GetModel() model.Model {
	return p.model
}

// SetModel sets the language model for the planner.
func (p *LLMPlanner) SetModel(m model.Model) {
	p.model = m
}
