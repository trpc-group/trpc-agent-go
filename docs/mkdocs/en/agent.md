# Agent Usage Documentation

Agent is the core execution unit of the tRPC-Agent-Go framework, responsible for processing user input and generating corresponding responses. Each Agent implements a unified interface, supporting streaming output and callback mechanisms.

The framework provides multiple types of Agents, including LLMAgent, ChainAgent, ParallelAgent, CycleAgent, and GraphAgent. This document focuses on LLMAgent. For detailed information about other Agent types and multi-Agent systems, please refer to [Multi-Agent](./multiagent.md).

## Quick Start

**Recommended Usage: Runner**

We strongly recommend using Runner to execute Agents instead of directly calling Agent interfaces. Runner provides a more user-friendly interface, integrating services like Session and Memory, making usage much simpler.

**ðŸ“– Learn More:** For detailed usage methods, please refer to [Runner](./runner.md)

This example uses OpenAI's GPT-4o-mini model. Before starting, please ensure you have prepared the corresponding `OPENAI_API_KEY` and exported it through environment variables:

```shell
export OPENAI_API_KEY="your_api_key"
```

Additionally, the framework supports OpenAI API-compatible models, which can be configured through environment variables:

```shell
export OPENAI_BASE_URL="your_api_base_url"
export OPENAI_API_KEY="your_api_key"
```

### Creating Model Instance

First, you need to create a model instance. Here we use OpenAI's GPT-4o-mini model:

```go
import "trpc.group/trpc-go/trpc-agent-go/model/openai"

modelName := flag.String("model", "gpt-4o-mini", "Name of the model to use")
flag.Parse()
// Create OpenAI model instance.
modelInstance := openai.New(*modelName, openai.Options{})
```

### Configuring Generation Parameters

Set the model's generation parameters, including maximum tokens, temperature, and whether to use streaming output:

```go
import "trpc.group/trpc-go/trpc-agent-go/model"

maxTokens := 1000
temperature := 0.7
genConfig := model.GenerationConfig{
    MaxTokens:   &maxTokens,   // Maximum number of tokens to generate.
    Temperature: &temperature, // Temperature parameter, controls output randomness.
    Stream:      true,         // Enable streaming output.
}
```

### Creating LLMAgent

Use the model instance and configuration to create an LLMAgent, while setting the Agent's Description and Instruction.

Description is used to describe the basic functionality and characteristics of the Agent, while Instruction defines the specific instructions and behavioral guidelines that the Agent should follow when executing tasks.

```go
import "trpc.group/trpc-go/trpc-agent-go/agent/llmagent"

llmAgent := llmagent.New(
    "demo-agent",                      // Agent name.
    llmagent.WithModel(modelInstance), // Set model.
    llmagent.WithDescription("A helpful AI assistant for demonstrations"),              // Set description.
    llmagent.WithInstruction("Be helpful, concise, and informative in your responses"), // Set instruction.
    llmagent.WithGenerationConfig(genConfig),                                           // Set generation parameters.
    // Set the filter mode for messages passed to the model. The final messages passed to the model must satisfy both WithMessageTimelineFilterMode and WithMessageBranchFilterMode conditions.
    // Timeline dimension filter conditions
    // Default: llmagent.TimelineFilterAll
    // Optional values:
    //  - llmagent.TimelineFilterAll: Includes historical messages as well as messages generated in the current request
    //  - llmagent.TimelineFilterCurrentRequest: Only includes messages generated in the current request
    //  - llmagent.TimelineFilterCurrentInvocation: Only includes messages generated in the current invocation context
    llmagent.WithMessageTimelineFilterMode(llmagent.TimelineFilterAll),

    // Branch dimension filter conditions
    // Default: llmagent.BranchFilterModePrefix
    // Optional values:
    //  - llmagent.BranchFilterModeAll: Includes messages from all agents. Use this when the current agent interacts with the model and needs to synchronize all valid content messages generated by all agents to the model.
    //  - llmagent.BranchFilterModePrefix: Filters messages by prefix matching Event.FilterKey with Invocation.eventFilterKey. Use this when you want to pass messages generated by the current agent and related upstream/downstream agents to the model.
    //  - llmagent.BranchFilterModeExact: Filters messages where Event.FilterKey == Invocation.eventFilterKey. Use this when the current agent interacts with the model and only needs to use messages generated by the current agent.
    llmagent.WithMessageBranchFilterMode(llmagent.BranchFilterModeAll),
)
```

### Placeholder Variables (Session State Injection)

LLMAgent automatically injects session state into `Instruction` and the optional `SystemPrompt` via placeholder variables. Supported patterns:

- `{key}`: Replace with the string value of `session.State["key"]`
- `{key?}`: Optional; if missing, replaced with an empty string
- `{user:subkey}` / `{app:subkey}` / `{temp:subkey}`: Use user/app/temp scoped keys (session services merge app/user state into session with these prefixes)
- `{invocation:subkey}:` Replaces with the value of fmt.Sprintf("%+v", `invocation.state["subkey"]`). (The state can be set via invocation.SetState(k, v))

Notes:

- If a non-optional key is not found, the original `{key}` is preserved (helps the LLM notice missing context)
- Values are read from `invocation.Session.State` (Runner + SessionService set/merge this automatically)

Example:

```go
llm := llmagent.New(
  "research-agent",
  llmagent.WithModel(modelInstance),
  llmagent.WithInstruction(
    "You are a research assistant. Focus: {research_topics}. " +
    "User interests: {user:topics?}. App banner: {app:banner?}.",
  ),
)

inv := agent.NewInvoction()
inv.SetState("case", "case-1")

// Initialize session state (Runner + SessionService)
_ = sessionService.UpdateUserState(ctx, session.UserKey{AppName: app, UserID: user}, session.StateMap{
  "topics": []byte("quantum computing, cryptography"),
})
_ = sessionService.UpdateAppState(ctx, app, session.StateMap{
  "banner": []byte("Research Mode"),
})
// Unprefixed keys live directly in session.State
_, _ = sessionService.CreateSession(ctx, session.Key{AppName: app, UserID: user, SessionID: sid}, session.StateMap{
  "research_topics": []byte("AI, ML, DL"),
})
```

See also:

- Examples: `examples/placeholder`, `examples/outputkey`
- Session API: `docs/mkdocs/en/session.md`

### Using Runner to Execute Agent

Use Runner to execute the Agent, which is the recommended usage:

```go
import "trpc.group/trpc-go/trpc-agent-go/runner"

// Create Runner.
runner := runner.NewRunner("demo-app", llmAgent)

// Send message directly without creating complex Invocation.
message := model.NewUserMessage("Hello! Can you tell me about yourself?")
eventChan, err := runner.Run(ctx, "user-001", "session-001", message)
if err != nil {
    log.Fatalf("Failed to execute Agent: %v", err)
}
```

### Message Visibility Options
The Agent can dynamically manage the visibility of messages generated by other Agents and historical session messages based on different scenarios. This is configurable through relevant options.
When interacting with the model, only the visible content is passed as input.

TIPS:
- Messages from different sessionIDs are never visible to each other under any circumstances. The following control strategies only apply to messages sharing the same sessionID.
- Invocation.Message always visible regardless of the configuration.
- When the option is not configured, the default value is FullContext.

Config:
- `llmagent.WithMessageFilterMode(MessageFilterMode)`:
  - `FullContext`: Includes historical messages and messages generated in the current request, filtered by prefix matching with the filterKey.
  - `RequestContext`: Only includes messages generated in the current request, filtered by prefix matching with the filterKey.
  - `IsolatedRequest`: Only includes messages generated in the current request, filtered by exact matching with the filterKey.
  - `IsolatedInvocation`: Only includes messages generated in the current Invocation context, filtered by exact matching with the filterKey.

Recommended Usage Examples (These examples are simplified configurations based on advanced usage):

```go
taskagentA := llmagent.New(
  "coordinator",
  llmagent.WithModel(modelInstance),
  // Makes all messages generated by taskagentA and taskagentB visible (including historical session messages under the same sessionID)
  llmagent.WithMessageFilterMode(llmagent.FullContext),
  // Makes all messages generated during the current runner.Run of taskagentA and taskagentB visible (excluding historical session messages)
  llmagent.WithMessageFilterMode(llmagent.RequestContext),
  // Only makes messages generated during the current runner.Run of taskagentA visible (excluding its own historical session messages)
  llmagent.WithMessageFilterMode(llmagent.IsolatedRequest),
  // Agent execution order: taskagentA-invocation1 -> taskagentB-invocation2 -> taskagentA-invocation3 (current execution phase)
  // Only makes messages generated during the current taskagentA-invocation3 phase visible (excluding its own historical session messages and messages generated during taskagentA-invocation1)
  llmagent.WithMessageFilterMode(llmagent.IsolatedInvocation),
)

taskagentB := llmagent.New(
  "coordinator",
  llmagent.WithModel(modelInstance),
  // Makes all messages generated by taskagentA and taskagentB visible (including historical session messages under the same sessionID)
  llmagent.WithMessageFilterMode(llmagent.FullContext),
  // Makes all messages generated during the current runner.Run of taskagentA and taskagentB visible (excluding historical session messages)
  llmagent.WithMessageFilterMode(llmagent.RequestContext),
  // Only makes messages generated during the current runner.Run of taskagentB visible (excluding its own historical session messages)
  llmagent.WithMessageFilterMode(llmagent.IsolatedRequest),
  // Agent execution order: taskagentA-invocation1 -> taskagentB-invocation2 -> taskagentA-invocation3 -> taskagentB-invocation4 (current execution phase)
  // Only makes messages generated during the current taskagentB-invocation4 phase visible (excluding its own historical session messages and messages generated during taskagentB-invocation2)
  llmagent.WithMessageFilterMode(llmagent.IsolatedInvocation),
)

// Cyclically execute taskagentA and taskagentB
cycleAgent := cycleagent.New(
  "coordinator",
  llmagent.WithModel(modelInstance),
  llmagent.WithSubAgents([]agent.Agent{taskagentA, taskagentB}),
  llmagent.WithMessageFilterMode(llmagent.FullContext)
)

// Create Runner
runner := runner.NewRunner("demo-app", cycleAgent)

// Send message directly without creating complex Invocation
message := model.NewUserMessage("Hello! Can you tell me about yourself?")
eventChan, err := runner.Run(ctx, "user-001", "session-001", message)
if err != nil {
    log.Fatalf("Failed to run Agent: %v", err)
}
```

Advanced Usage Examples:
You can independently control the visibility of historical messages and messages generated by other Agents for the current agent using WithMessageTimelineFilterModeand WithMessageBranchFilterMode.
When the current agent interacts with the model, only messages satisfying both conditions are input to the model. (invocation.Messageis always visible in any scenario.)
- `WithMessageTimelineFilterMode`: Controls visibility from a temporal dimension
  - `TimelineFilterAll`: Includes historical messages and messages generated in the current request.
  - `TimelineFilterCurrentRequest`: Only includes messages generated in the current request (one runner.Runcounts as one request).
  - `TimelineFilterCurrentInvocation`: Only includes messages generated in the current invocation context.
- `WithMessageBranchFilterMode`: Controls visibility from a branch dimension (used to manage visibility of messages generated by other agents).
  - `BranchFilterModePrefix`: Uses prefix matching between Event.FilterKeyand Invocation.eventFilterKey.
  - `BranchFilterModeAll`: Includes messages from all agents.
  - `BranchFilterModeExact`: Only includes messages generated by the current agent.

```go
llmAgent := llmagent.New(
    "demo-agent",                      // Agent name
    llmagent.WithModel(modelInstance), // Set the model
    llmagent.WithDescription("A helpful AI assistant for demonstrations"),              // Set description
    llmagent.WithInstruction("Be helpful, concise, and informative in your responses"), // Set instruction
    llmagent.WithGenerationConfig(genConfig),                                           // Set generation parameters

    // Set the message filtering mode for input to the model. The final messages passed to the model must satisfy both WithMessageTimelineFilterMode and WithMessageBranchFilterMode conditions.
    // Temporal dimension filtering condition
    // Default: llmagent.TimelineFilterAll
    // Options:
    //  - llmagent.TimelineFilterAll: Includes historical messages and messages generated in the current request.
    //  - llmagent.TimelineFilterCurrentRequest: Only includes messages generated in the current request.
    //  - llmagent.TimelineFilterCurrentInvocation: Only includes messages generated in the current invocation context.
    llmagent.WithMessageTimelineFilterMode(llmagent.TimelineFilterAll),
    // Branch dimension filtering condition
    // Default: llmagent.BranchFilterModePrefix
    // Options:
    //  - llmagent.BranchFilterModeAll: Includes messages from all agents. Use this when the current agent needs to sync valid content messages generated by all agents to the model during interaction.
    //  - llmagent.BranchFilterModePrefix: Filters messages by prefix matching Event.FilterKey with Invocation.eventFilterKey. Use this when you want to pass messages generated by the current agent and related upstream/downstream agents to the model.
    //  - llmagent.BranchFilterModeExact: Filters messages where Event.FilterKey exactly matches Invocation.eventFilterKey. Use this when the current agent only needs to use messages generated by itself during model interaction.
    llmagent.WithMessageBranchFilterMode(llmagent.BranchFilterModeAll),
)
```

### Reasoning Content Mode (DeepSeek Thinking Mode)

When using models with thinking/reasoning capabilities (such as DeepSeek), the model outputs both `reasoning_content` (thinking chain) and `content` (final answer). According to [DeepSeek API documentation](https://api-docs.deepseek.com/guides/thinking_mode), in multi-turn conversations, you should not send the previous turn's `reasoning_content` to the model.

LLMAgent provides `WithReasoningContentMode` to control how `reasoning_content` is handled in conversation history:

**Available Modes:**

| Mode | Constant | Description |
|------|----------|-------------|
| Discard Previous Turns | `ReasoningContentModeDiscardPreviousTurns` | Discard `reasoning_content` from previous request turns, keep for current request. **(Default, recommended)** |
| Keep All | `ReasoningContentModeKeepAll` | Keep all `reasoning_content` in history (for debugging). |
| Discard All | `ReasoningContentModeDiscardAll` | Discard all `reasoning_content` from history for maximum bandwidth savings. |

**Usage Example:**

```go
// Recommended configuration for DeepSeek models with thinking mode.
agent := llmagent.New(
    "deepseek-agent",
    llmagent.WithModel(deepseekModel),
    llmagent.WithInstruction("You are a helpful assistant."),
    // Discard reasoning_content from previous turns (recommended for DeepSeek).
    llmagent.WithReasoningContentMode(llmagent.ReasoningContentModeDiscardPreviousTurns),
)
```

**How It Works:**

- **`keep_all`**: All `reasoning_content` is preserved in session history. Use this if you need to retain thinking chains for debugging or analysis.
- **`discard_previous_turns`**: When building the message list for a new request, `reasoning_content` from messages belonging to previous requests is cleared. Messages within the current request (e.g., during tool call loops) retain their `reasoning_content`. This follows DeepSeek's recommendation.
- **`discard_all`**: All `reasoning_content` is stripped from historical messages before sending to the model.

**Note:** This option only affects how historical messages are processed before sending to the model. The current response's `reasoning_content` is always captured and stored in session events.

### Delegation Visibility Options

When building multiâ€‘Agent systems (task delegation between Agents), LLMAgent provides a unified fallback option for delegation events. Transfer events always include announcement text and are tagged `transfer` so UIs (User Interfaces) can filter them if desired.

- `llmagent.WithDefaultTransferMessage(string)`
  - Configure the default message used when a model calls a SubAgent without a `message`.
  - Pass an empty string to disable injecting a default message; pass a nonâ€‘empty string to enable and override it.

Usage example:

```go
coordinator := llmagent.New(
  "coordinator",
  llmagent.WithModel(modelInstance),
  llmagent.WithSubAgents([]agent.Agent{mathAgent, weatherAgent}),
  // Transfer announcement events are always emitted (tagged `transfer`). Filter in the UI if needed.
  // Customize the default message when the model omits it (empty string disables)
  llmagent.WithDefaultTransferMessage("Handing off to the specialist"),
)
```

Notes:

- These options do not change the actual handoff logic; they only affect userâ€‘visible texts or whether a fallback `message` is injected.
- Transfer announcements are emitted as Events with `Response.Object == "agent.transfer"`. If your UI should not display systemâ€‘level notices, filter this object type at the renderer/service layer.

### Handling Event Stream

The `eventChan` returned by `runner.Run()` is an event channel. The Agent continuously sends Event objects to this channel during execution.

Each Event contains execution state information at a specific moment: LLM-generated content, tool call requests and results, error messages, etc. By iterating through the event channel, you can get real-time execution progress (see [Event](#event) section below for details).

Receive execution results through the event channel:

```go
// 1. Get event channel (returns immediately, starts async execution)
eventChan, err := runner.Run(ctx, userID, sessionID, message)
if err != nil {
    log.Fatalf("Failed to start: %v", err)
}

// 2. Handle event stream (receive execution results in real-time)
for event := range eventChan {
    // Check for errors
    if event.Error != nil {
        log.Printf("Execution error: %s", event.Error.Message)
        continue
    }

    // Handle response content
    if len(event.Response.Choices) > 0 {
        choice := event.Response.Choices[0]

        // Streaming content (real-time display)
        if choice.Delta.Content != "" {
            fmt.Print(choice.Delta.Content)
        }

        // Tool call information
        for _, toolCall := range choice.Message.ToolCalls {
            fmt.Printf("Calling tool: %s\n", toolCall.Function.Name)
        }
    }

    // Check if completed (note: should not break on tool call completion)
    if event.IsFinalResponse() {
        fmt.Println()
        break
    }
}
```

The complete code for this example can be found at [examples/runner](https://github.com/trpc-group/trpc-agent-go/tree/main/examples/runner)

**Why is Runner recommended?**

1. **Simpler Interface**: No need to create complex Invocation objects
2. **Integrated Services**: Automatically integrates Session, Memory and other services
3. **Better Management**: Unified management of Agent execution flow
4. **Production Ready**: Suitable for production environment use

**ðŸ’¡ Tip:** Want to learn more about Runner's detailed usage and advanced features? Please check [Runner](./runner.md)

**Advanced Usage: Direct Agent Usage**

If you need more fine-grained control, you can also use the Agent interface directly, but this requires creating Invocation objects:

## Core Concepts

### Invocation (Advanced Usage)

Invocation is the context object for Agent execution flow, containing all information needed for a single call. **Note: This is advanced usage, we recommend using Runner to simplify operations.**

```go
import "trpc.group/trpc-go/trpc-agent-go/agent"

// Create Invocation object (advanced usage).
invocation := agent.NewInvocation(
    agent.WithAgentName(agent),                                                                  // Agent.
    agent.WithInvocationMessage(model.NewUserMessage("Hello! Can you tell me about yourself?")), // User message.
    agent.WithInvocationSession(&session.Session{ID: "session-001"}),                            // session object.
    agent.WithInvocationEndInvocation(false),                                                    // Whether to end invocation.
    agent.WithInvocationModel(modelInstance),                                                    // Model to use.
)

// Call Agent directly (advanced usage).
ctx := context.Background()
eventChan, err := llmAgent.Run(ctx, invocation)
if err != nil {
    log.Fatalf("Failed to execute Agent: %v", err)
}
```

**When to use direct calls?**

- Need complete control over execution flow
- Custom Session and Memory management
- Implement special invocation logic
- Debugging and testing scenarios

```go
// Invocation is the context object for Agent execution flow, containing
// all information needed for a single call.
type Invocation struct {
    // Agent specifies the Agent instance to call.
    Agent Agent
    // AgentName identifies the name of the Agent instance to call.
    AgentName string
    // InvocationID provides a unique identifier for each call.
    InvocationID string
    // Branch is a branch identifier for hierarchical event filtering.
    Branch string
    // EndInvocation indicates whether to end the invocation.
    EndInvocation bool

    // Session maintains the context state of the conversation.
    Session *session.Session
    // Model specifies the model instance to use.
    Model model.Model
    // Message is the specific content sent by the user to the Agent.
    Message model.Message
    // RunOptions are option configurations for the Run call.
    RunOptions RunOptions
    // TransferInfo supports control transfer between Agents.
    TransferInfo *TransferInfo

    // Structured output configuration (optional).
    StructuredOutput     *model.StructuredOutput
    StructuredOutputType reflect.Type

    // Services injected for this invocation.
    MemoryService   memory.Service
    ArtifactService artifact.Service

    // Internal signaling: notify when events are appended.
    noticeChanMap map[string]chan any
    noticeMu      *sync.Mutex

    // Internal: event filter key and parent linkage for nested flows.
    eventFilterKey string
    parent         *Invocation

    // Invocation-scoped state (lazy-init, thread-safe via stateMu).
    state   map[string]any
    stateMu sync.RWMutex

    // Optional per-invocation safety limits (usually set by LLMAgent).
    MaxLLMCalls      int
    MaxToolIterations int

    // Internal counters used to enforce MaxLLMCalls / MaxToolIterations.
    llmCallCount       int
    toolIterationCount int
}
```

#### Invocation State

`Invocation` provides a general-purpose state storage mechanism for sharing data within the lifecycle of a single invocation. This is useful for callbacks, middleware, or any scenario that requires storing temporary data at the invocation level.

**Core Methods:**

```go
// Set a state value
inv.SetState(key string, value any)

// Get a state value
value, ok := inv.GetState(key string)

// Delete a state value
inv.DeleteState(key string)
```

**Features:**

- **Invocation-scoped**: State is automatically scoped to a single invocation
- **Thread-safe**: Built-in RWMutex protection for concurrent access
- **Lazy initialization**: Memory allocated only on first use
- **General-purpose**: Can be used for callbacks, middleware, custom logic, and more

**Usage Example:**

> **Version Requirement**  
> The structured callback API (recommended) requires **trpc-agent-go >= 0.6.0**.

```go
// Store data in BeforeAgentCallback
// Note: Structured callback API requires trpc-agent-go >= 0.6.0
callbacks := agent.NewCallbacks()
callbacks.RegisterBeforeAgent(func(ctx context.Context, args *agent.BeforeAgentArgs) (*agent.BeforeAgentResult, error) {
    args.Invocation.SetState("agent:start_time", time.Now())
    args.Invocation.SetState("custom:request_id", "req-123")
    return nil, nil
})

// Read data in AfterAgentCallback
callbacks.RegisterAfterAgent(func(ctx context.Context, args *agent.AfterAgentArgs) (*agent.AfterAgentResult, error) {
    if startTime, ok := args.Invocation.GetState("agent:start_time"); ok {
        duration := time.Since(startTime.(time.Time))
        log.Printf("Execution took: %v", duration)
        args.Invocation.DeleteState("agent:start_time")
    }
    return nil, nil
})
```

**Recommended Key Naming Convention:**

- Agent callbacks: `"agent:xxx"`
- Model callbacks: `"model:xxx"`
- Tool callbacks: `"tool:toolName:xxx"`
- Middleware: `"middleware:xxx"`
- Custom logic: `"custom:xxx"`

For detailed usage and more examples, please refer to [Callbacks](./callbacks.md#invocation-state-sharing-data-between-callbacks).

### Event

Event is the real-time feedback generated during Agent execution, reporting execution progress in real-time through Event streams.

Events mainly include the following types:

- Model conversation events
- Tool call and response events
- Agent transfer events
- Error events

```go
// Event is the real-time feedback generated during Agent execution, reporting execution progress in real-time through Event streams.
type Event struct {
	// Response contains model response content, tool call results and statistics.
	*model.Response
	// InvocationID is associated with a specific invocation.
	InvocationID string `json:"invocationId"`
	// Author is the source of the event, such as Agent or tool.
	Author string `json:"author"`
	// ID is the unique identifier of the event.
	ID string `json:"id"`
	// Timestamp records the time when the event occurred.
	Timestamp time.Time `json:"timestamp"`
	// Branch is a branch identifier for hierarchical event filtering.
	Branch string `json:"branch,omitempty"`
	// RequiresCompletion identifies whether this event requires a completion signal.
	RequiresCompletion bool `json:"requiresCompletion,omitempty"`
	// LongRunningToolIDs is a set of IDs for long-running function calls. Agent clients can understand which function calls are long-running through this field, only valid for function call events.
	LongRunningToolIDs map[string]struct{} `json:"longRunningToolIDs,omitempty"`
}
```

The streaming nature of Events allows you to see the Agent's working process in real-time, just like having a natural conversation with a real person. You only need to iterate through the Event stream, check the content and status of each Event, and you can completely handle the Agent's execution results.

### Agent Interface

The Agent interface defines the core behaviors that all Agents must implement. This interface allows you to uniformly use different types of Agents while supporting tool calls and sub-Agent management.

```go
type Agent interface {
    // Run receives execution context and invocation information, returns an event channel. Through this channel, you can receive Agent execution progress and results in real-time.
    Run(ctx context.Context, invocation *Invocation) (<-chan *event.Event, error)
    // Tools returns the list of tools that this Agent can access and execute.
    Tools() []tool.Tool
    // Info method provides basic information about the Agent, including name and description, for easy identification and management.
    Info() Info
    // SubAgents returns the list of sub-Agents available to this Agent.
    // SubAgents and FindSubAgent methods support collaboration between Agents. An Agent can delegate tasks to other Agents, building complex multi-Agent systems.
    SubAgents() []Agent
    // FindSubAgent finds sub-Agent by name.
    FindSubAgent(name string) Agent
}
```

The framework provides multiple types of Agent implementations, including LLMAgent, ChainAgent, ParallelAgent, CycleAgent, and GraphAgent. For detailed information about different types of Agents and multi-Agent systems, please refer to [Multi-Agent](./multiagent.md).

## Callbacks

Callbacks provide a rich callback mechanism that allows you to inject custom logic at key points during Agent execution.

> **Version Requirement**  
> The structured callback API (recommended) requires **trpc-agent-go >= 0.6.0**.

### Callback Types

The framework provides three types of callbacks:

**Agent Callbacks**: Triggered before and after Agent execution

```go
// Create callbacks using agent.NewCallbacks()
callbacks := agent.NewCallbacks()
```

**Model Callbacks**: Triggered before and after model calls

```go
// Create callbacks using model.NewCallbacks()
callbacks := model.NewCallbacks()
```

**Tool Callbacks**: Triggered before and after tool calls

```go
// Create callbacks using tool.NewCallbacks()
callbacks := tool.NewCallbacks()
```

### Usage Example

```go
// Create Agent callbacks (using structured API)
// Note: Structured callback API requires trpc-agent-go >= 0.6.0
callbacks := agent.NewCallbacks()
callbacks.RegisterBeforeAgent(func(ctx context.Context, args *agent.BeforeAgentArgs) (*agent.BeforeAgentResult, error) {
    log.Printf("Agent %s started execution", args.Invocation.AgentName)
    return nil, nil
})
callbacks.RegisterAfterAgent(func(ctx context.Context, args *agent.AfterAgentArgs) (*agent.AfterAgentResult, error) {
    if args.Error != nil {
        log.Printf("Agent %s execution error: %v", args.Invocation.AgentName, args.Error)
    } else {
        log.Printf("Agent %s execution completed", args.Invocation.AgentName)
    }
    return nil, nil
})

// Use callbacks in llmAgent
llmagent := llmagent.New("llmagent", llmagent.WithAgentCallbacks(callbacks))
```

The callback mechanism allows you to precisely control the Agent's execution process and implement more complex business logic.

## Advanced Usage

The framework provides advanced features like Runner, Session, and Memory for building more complex Agent systems.

**Runner is the recommended usage**, responsible for managing Agent execution flow, connecting Session/Memory Service capabilities, and providing a more user-friendly interface.

Session Service is used to manage session state, supporting conversation history and context maintenance.

Memory Service is used to record user preference information, supporting personalized experiences.

**Recommended Reading Order:**

1. [Runner](runner.md) - Learn the recommended usage
2. [Session](session.md) - Understand session management
3. [Multi-Agent](multiagent.md) - Learn multi-Agent systems

## Runtime Instruction Updates

You can update an Agentâ€™s behavior-defining text at runtime without rebuilding or restarting the Agent.

What changes dynamically

- Instruction: the behavior guideline appended to the system message.
- Global Instruction (system prompt): the system-level preface prepended to the request.

Both can be updated on an existing `LLMAgent` instance and take effect on subsequent model requests.

Example

```go
import (
    "context"

    "trpc.group/trpc-go/trpc-agent-go/agent/llmagent"
    "trpc.group/trpc-go/trpc-agent-go/model"
    "trpc.group/trpc-go/trpc-agent-go/model/openai"
    "trpc.group/trpc-go/trpc-agent-go/runner"
)

// 1) Build model and agent once at startup.
mdl := openai.New("gpt-4o-mini", openai.Options{})
llm := llmagent.New(
    "support-bot",
    llmagent.WithModel(mdl),
    llmagent.WithInstruction("Be helpful and concise."),
)
run := runner.NewRunner("my-app", llm)

// 2) Later, change behavior at runtime (e.g., user updates prompt in UI).
llm.SetInstruction("Translate all user inputs to French.")
llm.SetGlobalInstruction("System: Safety first. No PII leakage.")

// 3) Subsequent runs use the new instructions.
msg := model.NewUserMessage("Where is the nearest museum?")
ch, err := run.Run(context.Background(), "u1", "s1", msg)
_ = ch; _ = err
```

Notes

- Threadâ€‘safe: the setters are concurrencyâ€‘safe and can be called while the service is handling requests.
- Midâ€‘turn behavior: if an Agentâ€™s current turn triggers more than one model request (e.g., due to tool calls), updates may apply to subsequent requests in the same turn. If you need perâ€‘run stability, set or freeze the text at the start of the run.
- Perâ€‘session personalization: for perâ€‘user or perâ€‘session data, prefer placeholders in the instruction and session state injection (see the â€œPlaceholder Variablesâ€ section above).

### Alternative: Placeholderâ€‘Driven Dynamic System Prompts

If youâ€™d rather not call setters, you can make the instruction itself a template and feed values via session state. The instruction processor replaces placeholders using session/app/user state on each turn.

Patterns

- Persistent perâ€‘user value: store under `user:*` and reference `{user:key}`.
- Persistent perâ€‘app value: store under `app:*` and reference `{app:key}`.
- Perâ€‘turn ephemeral value: write into the sessionâ€™s `temp:*` namespace and reference `{temp:key}` (not persisted).

Example: perâ€‘user dynamic instruction

```go
import (
    "context"

    "trpc.group/trpc-go/trpc-agent-go/agent/llmagent"
    "trpc.group/trpc-go/trpc-agent-go/runner"
    "trpc.group/trpc-go/trpc-agent-go/session"
    "trpc.group/trpc-go/trpc-agent-go/session/inmemory"
)

svc := inmemory.NewSessionService()
app, user, sid := "my-app", "u1", "s1"

// 1) Instruction template references a user-scoped key.
llm := llmagent.New(
  "dyn-agent",
  llmagent.WithInstruction("{user:system_prompt}"),
)
run := runner.NewRunner(app, llm, runner.WithSessionService(svc))

// 2) Update the user-scoped state when the user changes settings.
_ = svc.UpdateUserState(context.Background(), session.UserKey{AppName: app, UserID: user}, session.StateMap{
  "system_prompt": []byte("You are a helpful assistant. Always answer in English."),
})

// 3) Runs now read the latest prompt via placeholder injection.
_, _ = run.Run(context.Background(), user, sid, model.NewUserMessage("Hi!"))
```

Example: perâ€‘turn temp value via a beforeâ€‘agent callback

> **Version Requirement**  
> The structured callback API (recommended) requires **trpc-agent-go >= 0.6.0**.

```go
// Note: Structured callback API requires trpc-agent-go >= 0.6.0
callbacks := agent.NewCallbacks()
callbacks.RegisterBeforeAgent(func(ctx context.Context, args *agent.BeforeAgentArgs) (*agent.BeforeAgentResult, error) {
  if args.Invocation != nil && args.Invocation.Session != nil {
    if args.Invocation.Session.State == nil {
      args.Invocation.Session.State = make(map[string][]byte)
    }
    // Write a one-off instruction for this turn only
    args.Invocation.Session.State["temp:sys"] = []byte("Translate to French.")
  }
  return nil, nil
})

llm := llmagent.New(
  "temp-agent",
  llmagent.WithInstruction("{temp:sys}"),
  llmagent.WithAgentCallbacks(callbacks), // requires trpc-agent-go >= 0.6.0
)
```

Caveats

- In-memory `UpdateUserState` intentionally forbids `temp:*` updates; write `temp:*` directly to `invocation.Session.State` (e.g., via a callback) when you need ephemeral, perâ€‘turn values.
- Placeholders are resolved at request time; changing the stored value updates behavior on the next model request without recreating the agent.
